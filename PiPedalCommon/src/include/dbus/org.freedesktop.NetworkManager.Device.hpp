
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__dbus_hpp_org_freedesktop_NetworkManager_Device_hpp__proxy__H__
#define __sdbuscpp__dbus_hpp_org_freedesktop_NetworkManager_Device_hpp__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace NetworkManager {

class Device_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.NetworkManager.Device";

protected:
    Device_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
        proxy_.uponSignal("StateChanged").onInterface(INTERFACE_NAME).call([this](const uint32_t& new_state, const uint32_t& old_state, const uint32_t& reason){ this->onStateChanged(new_state, old_state, reason); });
    }

    ~Device_proxy() = default;

    virtual void onStateChanged(const uint32_t& new_state, const uint32_t& old_state, const uint32_t& reason) = 0;

public:
    void Reapply(const std::map<std::string, std::map<std::string, sdbus::Variant>>& connection, const uint64_t& version_id, const uint32_t& flags)
    {
        proxy_.callMethod("Reapply").onInterface(INTERFACE_NAME).withArguments(connection, version_id, flags);
    }

    std::tuple<std::map<std::string, std::map<std::string, sdbus::Variant>>, uint64_t> GetAppliedConnection(const uint32_t& flags)
    {
        std::tuple<std::map<std::string, std::map<std::string, sdbus::Variant>>, uint64_t> result;
        proxy_.callMethod("GetAppliedConnection").onInterface(INTERFACE_NAME).withArguments(flags).storeResultsTo(result);
        return result;
    }

    void Disconnect()
    {
        proxy_.callMethod("Disconnect").onInterface(INTERFACE_NAME);
    }

    void Delete()
    {
        proxy_.callMethod("Delete").onInterface(INTERFACE_NAME);
    }

public:
    std::string Udi()
    {
        return proxy_.getProperty("Udi").onInterface(INTERFACE_NAME);
    }

    std::string Path()
    {
        return proxy_.getProperty("Path").onInterface(INTERFACE_NAME);
    }

    std::string Interface()
    {
        return proxy_.getProperty("Interface").onInterface(INTERFACE_NAME);
    }

    std::string IpInterface()
    {
        return proxy_.getProperty("IpInterface").onInterface(INTERFACE_NAME);
    }

    std::string Driver()
    {
        return proxy_.getProperty("Driver").onInterface(INTERFACE_NAME);
    }

    std::string DriverVersion()
    {
        return proxy_.getProperty("DriverVersion").onInterface(INTERFACE_NAME);
    }

    std::string FirmwareVersion()
    {
        return proxy_.getProperty("FirmwareVersion").onInterface(INTERFACE_NAME);
    }

    uint32_t Capabilities()
    {
        return proxy_.getProperty("Capabilities").onInterface(INTERFACE_NAME);
    }

    uint32_t Ip4Address()
    {
        return proxy_.getProperty("Ip4Address").onInterface(INTERFACE_NAME);
    }

    uint32_t State()
    {
        return proxy_.getProperty("State").onInterface(INTERFACE_NAME);
    }

    sdbus::Struct<uint32_t, uint32_t> StateReason()
    {
        return proxy_.getProperty("StateReason").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath ActiveConnection()
    {
        return proxy_.getProperty("ActiveConnection").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Ip4Config()
    {
        return proxy_.getProperty("Ip4Config").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Dhcp4Config()
    {
        return proxy_.getProperty("Dhcp4Config").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Ip6Config()
    {
        return proxy_.getProperty("Ip6Config").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Dhcp6Config()
    {
        return proxy_.getProperty("Dhcp6Config").onInterface(INTERFACE_NAME);
    }

    bool Managed()
    {
        return proxy_.getProperty("Managed").onInterface(INTERFACE_NAME);
    }

    void Managed(const bool& value)
    {
        proxy_.setProperty("Managed").onInterface(INTERFACE_NAME).toValue(value);
    }

    bool Autoconnect()
    {
        return proxy_.getProperty("Autoconnect").onInterface(INTERFACE_NAME);
    }

    void Autoconnect(const bool& value)
    {
        proxy_.setProperty("Autoconnect").onInterface(INTERFACE_NAME).toValue(value);
    }

    bool FirmwareMissing()
    {
        return proxy_.getProperty("FirmwareMissing").onInterface(INTERFACE_NAME);
    }

    bool NmPluginMissing()
    {
        return proxy_.getProperty("NmPluginMissing").onInterface(INTERFACE_NAME);
    }

    uint32_t DeviceType()
    {
        return proxy_.getProperty("DeviceType").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::ObjectPath> AvailableConnections()
    {
        return proxy_.getProperty("AvailableConnections").onInterface(INTERFACE_NAME);
    }

    std::string PhysicalPortId()
    {
        return proxy_.getProperty("PhysicalPortId").onInterface(INTERFACE_NAME);
    }

    uint32_t Mtu()
    {
        return proxy_.getProperty("Mtu").onInterface(INTERFACE_NAME);
    }

    uint32_t Metered()
    {
        return proxy_.getProperty("Metered").onInterface(INTERFACE_NAME);
    }

    std::vector<std::map<std::string, sdbus::Variant>> LldpNeighbors()
    {
        return proxy_.getProperty("LldpNeighbors").onInterface(INTERFACE_NAME);
    }

    bool Real()
    {
        return proxy_.getProperty("Real").onInterface(INTERFACE_NAME);
    }

    uint32_t Ip4Connectivity()
    {
        return proxy_.getProperty("Ip4Connectivity").onInterface(INTERFACE_NAME);
    }

    uint32_t Ip6Connectivity()
    {
        return proxy_.getProperty("Ip6Connectivity").onInterface(INTERFACE_NAME);
    }

    uint32_t InterfaceFlags()
    {
        return proxy_.getProperty("InterfaceFlags").onInterface(INTERFACE_NAME);
    }

    std::string HwAddress()
    {
        return proxy_.getProperty("HwAddress").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::ObjectPath> Ports()
    {
        return proxy_.getProperty("Ports").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

#endif
